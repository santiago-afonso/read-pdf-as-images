#!/usr/bin/env bash
set -euo pipefail

# read-pdf-as-images
# Rasterize selected PDF pages to images and emit a JSONL manifest to stderr.
# Defaults: PNG @ 220 DPI, output under tmp/pdf_renders/<filename>/page-<NNN>.png

usage() {
  cat <<'USAGE'
read-pdf-as-images â€” render PDF pages to images and emit JSONL to stderr

Usage:
  read-pdf-as-images <pdf> [--pages "1,3,7-12"] [--dpi 220] [--format png|jpeg] [--outdir DIR]

Defaults:
  --format png
  --dpi 220
  --outdir tmp/pdf_renders/<pdf-basename-no-ext>/

Behavior:
  - Files named page-<NNN>.<ext> with zero padding (NNN width = max(3, digits(total_pages))).
  - Always writes one JSONL line per generated page to stderr:
      {"page":7,"path":"tmp/pdf_renders/<name>/page-007.png","dpi":220,"format":"png"}
  - Stdout remains empty for easy piping. Errors/help go to stderr.

Examples:
  read-pdf-as-images "Input/Report.pdf" --pages "1,3,7-12"
  read-pdf-as-images "Input/Report.pdf" --dpi 300 --format jpeg

Dependencies: pdftoppm, pdfinfo (Poppler)
USAGE
}

err() { echo "ERROR: $*" >&2; }

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; exit 3; }
}

# Parse comma/range list like 1,3,7-12 into a sorted unique list
parse_pages() {
  local spec=$1
  local -a out=()
  IFS=',' read -r -a parts <<<"$spec"
  for part in "${parts[@]}"; do
    part=$(echo "$part" | tr -d ' ')
    [ -z "$part" ] && continue
    if [[ "$part" =~ ^[0-9]+$ ]]; then
      out+=("$part")
    elif [[ "$part" =~ ^([0-9]+)-([0-9]+)$ ]]; then
      local a=${BASH_REMATCH[1]} b=${BASH_REMATCH[2]}
      if (( a<=b )); then
        local i
        for (( i=a; i<=b; i++ )); do out+=("$i"); done
      else
        err "Invalid range: $part (start>end)"; exit 2
      fi
    else
      err "Invalid page token: $part"; exit 2
    fi
  done
  # sort -n and uniq
  printf '%s\n' "${out[@]}" | awk 'NF' | sort -n | uniq
}

# Group a sorted list of integers into contiguous ranges: echo "start end" per line
group_contiguous() {
  awk 'BEGIN{prev=-1;start=-1}
       {cur=$1; if (start==-1){start=cur; prev=cur; next}
        if (cur==prev+1){prev=cur; next}
        printf "%d %d\n", start, prev; start=cur; prev=cur}
       END{ if (start!=-1) printf "%d %d\n", start, prev }'
}

main() {
  local pdf=""
  local pages_spec=""
  local dpi=220
  local format="png"
  local outdir=""

  # Arg parsing
  if (( $#==0 )); then usage >&2; exit 2; fi
  while (( $#>0 )); do
    case "$1" in
      -h|--help) usage; exit 0 ;;
      --pages) shift || { usage >&2; exit 2; }; pages_spec=${1:-}; shift ;;
      --dpi) shift || { usage >&2; exit 2; }; dpi=${1:-}; shift ;;
      --format) shift || { usage >&2; exit 2; }; format=${1:-}; shift ;;
      --outdir) shift || { usage >&2; exit 2; }; outdir=${1:-}; shift ;;
      --*) err "Unknown flag: $1"; usage >&2; exit 2 ;;
      *) if [ -z "$pdf" ]; then pdf=$1; else err "Unexpected extra arg: $1"; usage >&2; exit 2; fi; shift ;;
    esac
  done

  [ -z "$pdf" ] && { err "Missing <pdf> argument"; usage >&2; exit 2; }
  [ ! -f "$pdf" ] && { err "PDF not found: $pdf"; exit 3; }

  # Dependencies
  need_cmd pdfinfo
  need_cmd pdftoppm

  # Validate format
  case "$format" in
    png|jpeg) :;;
    *) err "Unsupported --format: $format (png|jpeg)"; exit 2 ;;
  esac

  # Page count
  local page_count
  page_count=$(pdfinfo "$pdf" | sed -n 's/^Pages:[[:space:]]*//p')
  if ! [[ "$page_count" =~ ^[0-9]+$ ]]; then
    err "Could not determine page count for: $pdf"; exit 3
  fi

  # Default outdir if not provided
  if [ -z "$outdir" ]; then
    local base
    base=$(basename -- "$pdf")
    base=${base%.*}
    outdir="tmp/pdf_renders/$base"
  fi
  mkdir -p -- "$outdir"

  # Pages to render
  local -a pages=()
  if [ -n "$pages_spec" ]; then
    mapfile -t pages < <(parse_pages "$pages_spec")
  else
    # default: all pages
    local i
    for (( i=1; i<=page_count; i++ )); do pages+=("$i"); done
  fi

  # Validate range bounds
  if ((${#pages[@]}==0)); then err "No pages selected"; exit 2; fi
  local p
  for p in "${pages[@]}"; do
    if (( p<1 || p>page_count )); then
      err "Page out of bounds: $p (1..$page_count)"; exit 2
    fi
  done

  # Determine padding width
  local pad
  local digits=${#page_count}
  if (( digits<3 )); then pad=3; else pad=$digits; fi

  # Group into contiguous ranges and render
  local fmtflag
  fmtflag="-${format}"

  # Build grouped ranges
  local -a grouped=()
  mapfile -t grouped < <(printf '%s\n' "${pages[@]}" | group_contiguous)
  local range
  for range in "${grouped[@]}"; do
    local start end
    read -r start end <<<"$range"
    pdftoppm "$fmtflag" -rx "$dpi" -ry "$dpi" -f "$start" -l "$end" -- "$pdf" "$outdir/page" >/dev/null
  done

  # Emit JSONL for each selected page
  for p in "${pages[@]}"; do
    local fname
    # shellcheck disable=SC2059
    printf -v fname "%s/page-%0${pad}d.%s" "$outdir" "$p" "$format"
    if [ ! -f "$fname" ]; then
      err "Expected output missing: $fname"; exit 3
    fi
    printf '{"page":%d,"path":"%s","dpi":%d,"format":"%s"}\n' "$p" "$fname" "$dpi" "$format" >&2
  done
}

main "$@"

